
---
cssclass: img_grid
---


### 数字滤波器介绍

数字滤波器一般分为FIR滤波器和IIR滤波器，IIR滤波器的全称为无限长冲激响应滤波器，因为其实现包括对输出的反馈部分，因此IIR滤波器可以看成对所有输入的卷积结果，脉冲响应$h(n)$便是无线的。其差分方程为：
$$ y(n)=\sum_{i=0}^N a_{i}y(n-i)+\sum_{i=0}^M b_{i}x(n-1)\tag{1}$$
传递函数为：
$$H(z)=\frac{\sum_{i=0}^M b_{i}Z^{-i}}{1-\sum_{i=1}^N a_{i}Z^{-1}}=\frac{Y(z)}{X(z)}\tag{2}$$
FIR滤波器的全称为有限长冲激响应滤波器，结构上主要是非递归结构，没有输出到输入反馈，单位冲激响应$h(n)$在有限个n值处不为零。其差分方程为：
$$ y(n)=\sum_{i=0}^N b_{i}x(n-1)\tag{3}$$
传递函数为：
$$H(z)=\sum_{i=0}^N b_{i}Z^{-i}\tag{4}$$
FIR与IIR相比，其具有线性相位和结构简单的优点，在FPGA中的具体实现可以调用相关的IP核，因此FIR的实现是比较简单的。相比之下，IIR因其存在反馈结构，需要通过递归实现，也没有封装好的IP核能够直接调用，因此需要重点研究IIR滤波器在FPGA的实现。尽管IIR的实现比较复杂，且不具有线性相位的特点，但是其实现所用资源少，在相同的阻带衰减下相对于FIR滤波器IIR滤波器能够较大地减少FPGA资源的占用，同时也能带来通带内更小的相位延迟。因此，对于具有时时反馈结构的DPLL，其中的$2f$滤波器应选择IIR滤波器。
相同条件下FIR阶数和IIR阶数的对比：
参数设置：
![[1687327788041.png]]   
FIR滤波器：
![[1687327835678.png]]
IIR滤波器：
![[1687329156384.png|]]

### 基于FilterDesigner的数字滤波器设计

首先根据实际的需要设计出符合要求的IIR滤波器，建议使用matlab中filterDesigner图像化界面进行设计：
![[1687315290862.png]]
从上图可以看出对于低通滤波器的设计，比较重要的参数为：通带幅值$A_{pass}$、阻带幅值$A_{stop}$、通带截止频率$F_{pass}$、阻带频率$F_{stop}$。对于理想的低通滤波器，通带截止频率应该恰好等于阻带频率，而实际的低通滤波器阻带频率都高于通带截止频率，两者之间幅值响应存在一个衰减的过程。当$F_{pass}$和$F_{stop}$确定时，$A_{stop}$和$A_{pass}$的比值可以用来描述阻带的衰减速率，滤波器的阶数随衰减速率的增大而增大。
FilterDesigner提供多种IIR滤波器的设计，分别为Butterworth滤波器、切比雪夫I型、切比雪夫Ⅱ型、椭圆滤波器、最平坦、最小P范数、最小约束P范数，比较常用的类型为：
1）Butterworth滤波器
使用范围最广，因为其完美地保存了通带内的信号，并且在阻带内也没有波动，过度区域的衰减速度虽然比不上切比雪夫滤波器以及椭圆滤波器，但是也不算最慢；
2）切比雪夫滤波器
I型通带内存在纹波，阻带下降快且不存在纹波；Ⅱ型通带内平缓，阻带内存在等幅值的纹波。整体和理想滤波器的误差最小，所以应用场合较多，尤其是I型切比雪夫滤波器，如果能够将其波动因子设置得尽量小的话，其性能甚至比巴特沃斯滤波器要高。
3）椭圆滤波器
阻带下降最快，因此在相同的阻带衰减要求下，椭圆滤波器的阶数最小消耗的资源最少。但阻带和通带都存在纹波，这限制它的使用范围。
同阶数、同截止频率四种低通滤波器的对比：
![[1687332294008.png]]
[[设计思路]]中使用的IIR滤波器为4阶切比雪夫Ⅰ型，具体的参数为:
$$A_{pass}=1dB,A_{stop}=80dB,F_{pass}=1MHz,F_{stop}=8MHz\tag{5}$$
幅频和相频响应如下：
![[1686646077356_3Xup6bpblg.png]]
其滤波器系数为：
![[1687336080357.png]]
FPGA中不支持浮点数的运算，为了在FPGA中实现该IIR滤波器，必须要对滤波器的系数进行量化，使滤波器的所有系数都变为整数。系数量化为整数后，也会带来精度的损失，这样会导致滤波的响应与未量化前全精度系数的滤波器响应存在差异，更有甚者滤波器可能变得不稳定，失去了基本的滤波功能。因此，滤波器量化后需要对比前后的幅值和相频响应来选择合适的量化位数，以达到使用最少的量化位数同时又能保持其原有功能的目的。matlab代码如下：
```matlab
clc;
b= [
 5.63036478464e-07,2.252145913856e-06,3.378218870784e-06,2.252145913856e-06,5.63036478464e-07
  
];%分子
a= [
                  1,   -3.919088895784,    5.766436441062,   -3.775239412417,0.927901974936
];%分母
m=max(max(abs(a),abs(b)));
Qm=floor(log2(m/a(1)));
if Qm<log2(m/a(1))
    Qm=Qm+1;
end
Qm=2^Qm;
N=30;
Qb=round(b/Qm*(2^(N-1)-1));
Qa=round(a/Qm*(2^(N-1)-1));
[H,w]=freqz(b,a);%量化前频率响应

Hf=abs(H);
figure(1);
plot(w, 20*log10(Hf));
hold on;

[H1,w]=freqz(Qb,Qa);%量化后频率响应
Hf1=abs(H1);
Pf1=angle(H1);
plot(w, 20*log10(Hf1));
legend('未量化','30bit');
grid on;
figure(2);
plot(w,Pf1*180/pi);
```
不同量化位数对滤波器频率响应的影响：
幅频响应：
![[1687359976466.png]]
从上图可以看出随着量化位数的增加，量化后的滤波器的幅频响应逐渐接近未量化前的滤波器的幅频响应。虽然40bit的量化结果最好，但考虑到实现所需要的资源，最终选择了30bit的系数量化。
![[1687359933940.png]]
30bit量化后的滤波器系数为：
$$Q_a=[67108864,-263005603,386978998,-253352028,62270447]\tag{6}$$
$$Q_{b}=[38,151,227,151,38]\tag{7}$$
系数量化后的IIR滤波器的差分方程可以写成：
$$
\begin{align}
67108864y(n)=38[x(n)+x(n-4)]+151[x(n-1)+x(n-3)]+227x(n-1)-
\\
[-263005603y(n-1)+386978998y(n-2)-253352028y(n-3)]+62270447y(n-4)
\end{align}\tag{8}
$$
### IIR滤波器的实现结构
IIR滤波器的基本结构可以分为直接Ⅰ型、直接Ⅱ型、级联型与并联型结构。
1）直接Ⅰ型
根据差分方程，可以将IIR滤波器看成两部的组合。无反馈结构的零点部分：
$$\sum_{i=0}^M b_{i}x(n-1)\tag{9}$$
有反馈结构的极点部分：
$$\sum_{i=0}^N a_{i}y(n-i)\tag{10}$$
则IIR滤波器的实现结构如下：
![[1687425332737.png]]
2）直接Ⅱ型
直接Ⅱ型结构相当于将直接型Ⅰ结构的左右两个部分互换位置并且共享了延时单元，结构图如下图所示：
![[1687425538557.png]]
直接Ⅱ型只需要N个延时单元即可，比直接Ⅰ型少M个，计算起来更简单一些，对于直接Ⅰ型和直接Ⅱ型的结构，优点是简单直观，缺点就是系数对滤波器的控制关系不明显。
3）级联型
我们可以将IIR滤波器传递函数拆分成多个子函数乘积的形式，即：
$$H(z)=\frac{\sum_{i=0}^M b_{i}Z^{-i}}{1-\sum_{i=1}^N a_{i}Z^{-1}}=A\prod_{i=1}^k{H_{k}(z)}\tag{11}$$
其中$H_{k}(z)$称为二阶基本节，它的一般形式为：
$$H_{k}(z)=\frac{1+b_{1}z^{-1}+b_{2}z^{-2}}{1-a_{1}z^{-1}-a_{2}z^{-2}}\tag{12}$$
该形式的特点是有两个极点，每一个实系数的二阶数字滤波器$H_{k}(z)$的结构均可以用直接Ⅱ型结构，将子函数所代表的系统级联起来即可以得到 $H(z)$的级联型结构:
![[1687426043105.png]]
级联型结构有这几个特点：调整零极点结构方便；运算误差比直接型小，但是误差会逐级积累。
4）并联型
对于并联型结构我们可以将系统函数拆分成多个子函数之和的形式，即：
$$H(z)=A_{0}+\sum_{K=1}^{N_{1}}{\frac{A_{k}}{1-c_{k}z^{-1}}}+\sum_{K=1}^{N_{2}}\frac{1+b_{1}z^{-1}}{1-a_{1}z^{-1}-a_{2}z^{-2}}\tag{13}$$
该结构由$N_{1}$个一阶基本节、$N_{2}$个一阶基本节和一个常数项并联而成：
![[1687426823096.png]]
并联型结构的特点是：子系统的误差不相互影响；并联可单独调整极点，但不能调整零点。
### IIR滤波器的FPGA的具体实现
级联型结构因其便于准确实现数字滤波器的零极点，且受参数量化影响较小，因此应用较为广泛，下面将使用级联型结构实现设计的IIR滤波器。因为FilterDesigner默认的结构就是级联型，因此点击设计滤波器后直接将系数导出，可以使用快捷键Ctrl+E，或者点击菜单栏文件->导出：
![[1687447639538.png]]
导出的结果是两个矩阵，SOS矩阵中存放滤波器系数，G矩阵中存放增益：
![[1687447836820.png]]
![[1687447878684.png]]

SOS矩阵中每一行存放单节的滤波器系数，前三个值对应分子多项式系数，后三个值对应分母的多项式系数，由此可以得到两单节的传递函数：
$$H_{1}(z)=\frac{1+2z^{-1}+z^{-2}}{1-1.9723z^{-1}+0.9783z^{-2}}\tag{14}$$
$$H_{2}(z)=\frac{1+2z^{-1}+z^{-2}}{1-1.9468z^{-1}+0.9484z^{-2}}\tag{15}$$
考虑到实际的增益，则整体的传递函数为：
$$H(z)=G(1)G(2)G(3)H_{1}(z)H_{2}(z)\tag{16}$$
将增益加入后，为了平衡两个子节的实现难度，需将增益进行合理分配：
$$g=\sqrt{G(1)G(2)G(3)}$$
$$H_{1}^{'}(z)=gH_{1}(z)\tag{17}$$
$$H_{2}^{'}(z)=gH_{2}(z)\tag{18}$$
增益分配后我们可以得到两个子节的系数为：
子节1：
$$[0.00075,0.0015,0.00075,1,-1.97232,0.97834,]$$
子节2：
$$[0.00075,	0.0015,	0.00075,1,-1.94676,0.94844]$$
对两个子节的滤波器系数进行量化：
子节一14bit量化结果：
$$[3,6,3,4096,-8078,4007]$$
量化前后幅频响应对比：
![[1687496983118.png]]
子节二14bit量化结果：
$$[3,6,3,4096,-7973,3884]$$
量化前后幅频响应对比：
![[1687497086424.png]]
系数量化后两子节的差分方程为：
$$4096y_{1}(n)=3[x(n)+x(n-2)]+6x(n-1)-[-8078y_{1}(n-1)+4007y_{1}(n-2)]$$
$$4096y_{2}(n)=3[x(n)+x(n-2)]+6x(n-1)-[-7973y_{2}(n-1)+3884y_{2}(n-2)]$$
为了验证系数量化的正确性，先在simulink中实现该IIR滤波器：
子节一实现模型：
![[1687872158017.png]]
子节二实现模型：
![[1687872272500.png]]
将系数量化前后的滤波器模型接入相同的混频信号，对比输出结果：
![[1687499101279.png]]
从结果中可以看出系数量化后的滤波器输出与未系数量化前的滤波器输出十分接近，证明了系数量化的有效性。
在进行FPGA之前还需要将滤波器中常系数乘法运算进行优化，将其转化为移位和加法运算，需要将量化后滤波器系数进行2为底的幂级数展开，可以使用matlab自带的十进制转二进制函数dec2bin：
$$3='11'=2^1+2^0$$
$$6='110'=2^2+2^1$$
$$8078='1111110001110'=2^{12}+2^{11}+2^{10}+2^{9}+2^8+2^7+2^3+2^2+2^1=2^{13}-2^7+2^4-2$$
$$4007='111110100111'=2^{11}+2^{10}+2^9+2^8+2^7+2^5+2^3-2^0=2^{12}-2^7+2^5+2^3-1$$
$$7973='1111100100101'=2^{12}+2^{11}+2^{10}+2^{9}+2^{8}+2^5+2^2+2^0=2^{13}-2^8+2^5+2^2+1$$
$$3884='111100101100'=2^{11}+2^{10}+2^{9}+2^{8}+2^5+2^3+2^2=2^{12}-2^8+2^5+2^3+2^2$$
这样常系数乘法就可以转化为移位和加法运算，为了进一步提高运行速度，还可以用位拼接的方法代替移位的操作，具体参见后面的verilog代码。
整个级联型的IIR滤波器FPGA程序由3个文件组成：顶层文件（IIRcas.v）、第一节IIR滤波器实现文件（FirstTap.v）、第二节IIR滤波器实现文件（SencondTop.v）。顶层文件的代码如下：
```verilog
module IIRCas(rst,clk,Xin,Yout);
input rst;
input clk;
input signed[23:0] Xin;
output signed[23:0] Yout;    
wire signed[23:0] Y1;
FirstTap lf1(
        .rst(rst),
        .clk(clk),
        .Xin(Xin),
        .Yout(Y1) 
    );

SencondTap lf2(
        .rst(rst),
        .clk(clk),
        .Xin(Y1),
        .Yout(Yout)
   );

endmodule
```
综合之后的RTL原理图如下：
![[1687874623007.png]]
第一节的滤波器代码如下：
 ```verilog
 `timescale 1ns / 1ps
module FirstTap(rst,clk,Xin,Yout);
    input rst;
    input clk;
    input signed[23:0] Xin;
    output signed[23:0] Yout;
    //零点部分实现
    reg signed[23:0] Xin1,Xin2;
    always @(posedge clk or posedge rst)  
    if(rst)
    //高电平时复位 寄存器值全赋值为0
    begin
        Xin1<=24'd0;
        Xin2<=24'd0;    
    end
    else
    begin
        Xin1<=Xin;
        Xin2<=Xin1;      
    end
    //采样移位运算及加法运算实现乘法运算
    wire signed[26:0] XMult0,XMult1,XMult2;//最大系数为6  只需要增加3位就不会溢出
    assign XMult0={{2{Xin[23]}},Xin,1'd0}+{{3{Xin[23]}},Xin};//3=2+1
    assign XMult1={{1{Xin1[23]}},Xin1,2'd0}+{{2{Xin1[23]}},Xin1,1'd0};//6=4+2
    assign XMult2={{2{Xin2[23]}},Xin2,1'd0}+{{3{Xin2[23]}},Xin2};//3=2+1
    //对输出结果进行累加
    wire signed [28:0] Xout;//三个27位的数相加最大为29位
    assign Xout=XMult0+XMult1+XMult2;
    //极点系数的实现代码
    wire signed[23:0] Yin;
    reg signed[23:0] Yin1,Yin2;
    always @(posedge clk or posedge rst)
    if(rst)
    begin
        Yin1<=24'd0;
        Yin2<=24'd0;  
    end
    else
    begin
        Yin1<=Yin;
        Yin2<=Yin1;    
    end
    //14位量化系数 乘以24位  有符号数  得到37位有符号数
    wire signed [37:0] YMult1,YMult2;
    wire signed [37:0] Ysum,Ydiv;
    assign YMult1={{1{Yin1[23]}},Yin1,13'd0}-{{7{Yin1[23]}},Yin1,7'd0}+{{10{Yin1[23]}},Yin1,4'd0}-{{13{Yin1[23]}},Yin1,1'd0};//8078=2^13-2^7+2^4-2
    assign YMult2={{2{Yin2[23]}},Yin2,12'd0}-{{7{Yin2[23]}},Yin2,7'd0}+{{9{Yin2[23]}},Yin2,5'd0}+{{11{Yin2[23]}},Yin2,3'd0}-{{14{Yin2[23]}},Yin2};//4007=2^12-2^7+2^5+2^3-1
    assign Ysum=Xout+YMult1-YMult2;
    assign Ydiv={{12{Ysum[37]}},Ysum[37:12]};
    //根据simulink仿真第一节输出可以用24位有符号数字表示
    assign Yin=(rst ? 24'd0:{{1{Ydiv[37]}},Ydiv[22:0]});
    reg signed[23:0] Yout_reg;
    always @(posedge clk )
    Yout_reg<=Yin;
    assign Yout=Yout_reg;
endmodule
 ```
 行为仿真结果：
 ![[1687874897145.png]]
 输入信号为两个频率为$5MHz$正弦混频，滤波后只剩下直流成分，说明低通滤波器起到了良好滤除高频信号的作用。